name: Backend CD - Deploy to Production

on:
  push:
    branches: [ main ]
    paths:
      - 'micro-digiservices/**'
  workflow_dispatch:
    inputs:
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: 'false'
        type: boolean

env:
  DEPLOYMENT_ENV: production

jobs:
  # Pre-deployment validation
  pre-deployment:
    runs-on: ubuntu-latest
    outputs:
      migration_count: ${{ steps.count_migrations.outputs.count }}
      deployment_id: ${{ steps.deployment_id.outputs.id }}
    
    steps:
    - name: Ì≥• Checkout code
      uses: actions/checkout@v4
      
    - name: Ì¥¢ Count Migration Files
      id: count_migrations
      run: |
        migration_count=$(find micro-digiservices/database-migrations/src/main/resources/db/migration -name "*.sql" | wc -l)
        echo "count=$migration_count" >> $GITHUB_OUTPUT
        echo "Ì≥Ñ Found $migration_count migration files"
        
    - name: Ìø∑Ô∏è Generate Deployment ID
      id: deployment_id
      run: |
        deployment_id="deploy-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
        echo "id=$deployment_id" >> $GITHUB_OUTPUT
        echo "Ìø∑Ô∏è Deployment ID: $deployment_id"

  # Deploy to production
  deploy-production:
    needs: pre-deployment
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Ì≥• Checkout code
      uses: actions/checkout@v4
    
    - name: Ì∫Ä Deploy to Production Server
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ secrets.PROD_PORT || 22 }}
        script: |
          set -e  # Exit on any error
          
          echo "Ì∫Ä Starting production deployment..."
          echo "Ìø∑Ô∏è Deployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}"
          echo "Ì≥Ñ Migration files: ${{ needs.pre-deployment.outputs.migration_count }}"
          echo "========================================"
          
          # Navigate to project directory
          cd ~/microservices
          
          # Create deployment backup
          BACKUP_DIR="/tmp/backups/${{ needs.pre-deployment.outputs.deployment_id }}"
          mkdir -p "$BACKUP_DIR"
          echo "Ì≤æ Creating backup at $BACKUP_DIR"
          
          # Backup current state
          if [ -f docker-compose.yml ]; then
            cp docker-compose.yml "$BACKUP_DIR/"
          fi
          
          # Backup current migration state
          if docker compose ps postgresdb | grep -q "Up"; then
            docker compose exec -T postgresdb pg_dump -U user2711 -d localdb > "$BACKUP_DIR/database_backup.sql" || echo "‚ö†Ô∏è Database backup failed"
          fi
          
          # Pull latest code (includes new migrations)
          echo "Ì≥• Pulling latest code..."
          cd micro-digiservices
          git fetch origin
          git reset --hard origin/main
          git pull origin main
          cd ..
          
          # Verify migration files
          migration_files=$(find micro-digiservices/database-migrations/src/main/resources/db/migration -name "*.sql" | wc -l)
          echo "‚úÖ Found $migration_files migration files on server"
          
          # Load production environment
          if [ -f .env.prod ]; then
            source .env.prod
            echo "‚úÖ Production environment loaded"
          else
            echo "‚ùå .env.prod not found!"
            exit 1
          fi
          
          # Stop existing services gracefully
          echo "Ìªë Stopping existing services..."
          docker compose down --timeout 30
          
          # Start database first
          echo "Ì∑ÑÔ∏è Starting database..."
          docker compose --env-file .env.prod up -d postgresdb
          
          # Wait for database to be ready
          echo "‚è≥ Waiting for database to be ready..."
          timeout 120 bash -c "until docker compose exec -T postgresdb pg_isready -U $POSTGRES_USER -d $POSTGRES_DATABASE; do sleep 3; done"
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Database failed to start!"
            exit 1
          fi
          
          echo "‚úÖ Database is ready"
          
          # Check if we should skip migrations
          SKIP_MIGRATIONS="${{ github.event.inputs.skip_migrations }}"
          if [ "$SKIP_MIGRATIONS" = "true" ]; then
            echo "‚è≠Ô∏è Skipping migrations (manual override)"
          else
            # Run database migrations
            echo "Ì∑ÉÔ∏è Running database migrations..."
            
            # Show current migration status
            echo "Ì≥ã Current migration status:"
            docker compose exec -T postgresdb psql -U $POSTGRES_USER -d $POSTGRES_DATABASE -c "
              SELECT version, description, installed_on 
              FROM flyway_schema_history 
              ORDER BY installed_rank DESC 
              LIMIT 5;
            " 2>/dev/null || echo "No previous migrations found"
            
            # Run migrations using Docker Flyway
            docker compose --env-file .env.prod --profile migration up flyway-migrations
            
            # Check migration result
            migration_exit_code=$?
            if [ $migration_exit_code -eq 0 ]; then
              echo "‚úÖ Database migrations completed successfully!"
              
              # Show updated migration status
              echo "Ì≥ã Updated migration status:"
              docker compose exec -T postgresdb psql -U $POSTGRES_USER -d $POSTGRES_DATABASE -c "
                SELECT version, description, installed_on 
                FROM flyway_schema_history 
                ORDER BY installed_rank DESC 
                LIMIT 5;
              "
            else
              echo "‚ùå Database migrations failed!"
              echo "Ì≥ã Migration logs:"
              docker compose logs flyway-migrations
              
              echo "Ì¥Ñ Rolling back deployment..."
              docker compose down
              
              # Restore database if backup exists
              if [ -f "$BACKUP_DIR/database_backup.sql" ]; then
                echo "Ì¥Ñ Restoring database backup..."
                docker compose --env-file .env.prod up -d postgresdb
                sleep 10
                docker compose exec -T postgresdb psql -U $POSTGRES_USER -d $POSTGRES_DATABASE < "$BACKUP_DIR/database_backup.sql" || echo "Database restore failed"
              fi
              
              exit 1
            fi
          fi
          
          # Start application services
          echo "Ì∫Ä Starting application services..."
          docker compose --env-file .env.prod --profile services up -d
          
          # Wait for services to initialize
          echo "‚è≥ Waiting for services to initialize..."
          sleep 45
          
          # Health check services
          echo "Ìø• Running health checks..."
          services=("postgresdb:5432" "authorizationserver:8080" "userservice:8085" "gateway:8000" "discoveryserver:5002")
          failed_services=()
          
          for service in "${services[@]}"; do
            IFS=':' read -r name port <<< "$service"
            if timeout 15 bash -c "</dev/tcp/localhost/$port" 2>/dev/null; then
              echo "‚úÖ $name is healthy (port $port)"
            else
              echo "‚ö†Ô∏è $name is not responding (port $port)"
              failed_services+=("$name")
            fi
          done
          
          # Final deployment status
          echo ""
          echo "Ì≥ä Deployment Summary:"
          echo "========================================"
          docker compose ps
          
          if [ ${#failed_services[@]} -eq 0 ]; then
            echo ""
            echo "Ìæâ DEPLOYMENT SUCCESSFUL!"
            echo "Ìø∑Ô∏è Deployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}"
            echo "Ìºê Production URLs:"
            echo "  - Gateway: http://51.91.254.218:8000"
            echo "  - Authorization: http://51.91.254.218:8080"
            echo "  - User Service: http://51.91.254.218:8085"
            echo "  - Discovery: http://51.91.254.218:5002"
            echo ""
            echo "Ì≤æ Backup location: $BACKUP_DIR"
            echo "========================================"
          else
            echo ""
            echo "‚ö†Ô∏è DEPLOYMENT COMPLETED WITH ISSUES"
            echo "Failed services: ${failed_services[*]}"
            echo "Ì≥ã Check logs: docker compose logs [service-name]"
            echo "Ì≤æ Backup available at: $BACKUP_DIR"
            echo "========================================"
          fi

  # Post-deployment verification
  post-deployment:
    needs: [pre-deployment, deploy-production]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Ì¥ç Verify Deployment
      run: |
        echo "Ì¥ç Post-deployment verification..."
        
        # Test basic connectivity
        services=("8080" "8085" "8000" "5002")
        for port in "${services[@]}"; do
          if curl -f -s --max-time 10 "http://51.91.254.218:$port/actuator/health" >/dev/null; then
            echo "‚úÖ Service on port $port is responding"
          else
            echo "‚ö†Ô∏è Service on port $port is not responding"
          fi
        done
        
    - name: Ì≥ã Deployment Report
      run: |
        echo "Ì≥ã Deployment Report"
        echo "==================="
        echo "Ìø∑Ô∏è Deployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}"
        echo "Ì¥Ñ Git Commit: ${{ github.sha }}"
        echo "Ì±§ Triggered by: ${{ github.actor }}"
        echo "Ì≥Ñ Migration files: ${{ needs.pre-deployment.outputs.migration_count }}"
        echo "Ìµê Deployment time: $(date)"
        echo "==================="
