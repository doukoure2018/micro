name: Backend CD - Deploy to Production

on:
  push:
    branches: [ main ]
    paths:
      - 'micro-digiservices/**'
  workflow_dispatch:
    inputs:
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: 'false'
        type: boolean

env:
  DEPLOYMENT_ENV: production

jobs:
  # Pre-deployment validation
  pre-deployment:
    runs-on: ubuntu-latest
    outputs:
      migration_count: ${{ steps.count_migrations.outputs.count }}
      deployment_id: ${{ steps.deployment_id.outputs.id }}
    
    steps:
    - name: ÔøΩ Checkout code
      uses: actions/checkout@v4
      
    - name: ÔøΩ Count Migration Files
      id: count_migrations
      run: |
        migration_count=$(find micro-digiservices/database-migrations/src/main/resources/db/migration -name "*.sql" | wc -l)
        echo "count=$migration_count" >> $GITHUB_OUTPUT
        echo "ÔøΩ Found $migration_count migration files"
        
    - name: ÔøΩÔ∏è Generate Deployment ID
      id: deployment_id
      run: |
        deployment_id="deploy-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
        echo "id=$deployment_id" >> $GITHUB_OUTPUT
        echo "ÔøΩÔ∏è Deployment ID: $deployment_id"

  # Deploy to production
  deploy-production:
    needs: pre-deployment
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: ÔøΩ Checkout code
      uses: actions/checkout@v4
    
    - name: ÔøΩ Deploy to Production Server
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USERNAME }}
        key: ${{ secrets.PROD_SSH_KEY }}
        port: ${{ secrets.PROD_PORT || 22 }}
        script: |
          set -e  # Exit on any error
          
          echo "ÔøΩ Starting production deployment..."
          echo "ÔøΩÔ∏è Deployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}"
          echo "ÔøΩ Migration files: ${{ needs.pre-deployment.outputs.migration_count }}"
          echo "========================================"
          
          # Navigate to project directory
          cd ~/microservices
          
          # Create deployment backup
          BACKUP_DIR="/tmp/backups/${{ needs.pre-deployment.outputs.deployment_id }}"
          mkdir -p "$BACKUP_DIR"
          echo "üíæ Creating backup at $BACKUP_DIR"
          
          # Backup current state
          if [ -f docker-compose.yml ]; then
            cp docker-compose.yml "$BACKUP_DIR/"
          fi
          
          # Backup current migration state
          if docker compose ps postgresdb | grep -q "Up"; then
            docker compose exec -T postgresdb pg_dump -U user2711 -d localdb > "$BACKUP_DIR/database_backup.sql" || echo "‚ö†Ô∏è Database backup failed"
          fi
          
          # Remove any existing source code directory (for clean deployment)
          rm -rf micro-digiservices/
          
          # Clone fresh from GitHub for this deployment
          echo "üì• Cloning latest code from GitHub..."
          git clone https://github.com/doukoure2018/micro.git temp-deployment
          mv temp-deployment micro-digiservices
          
          # Verify migration files are available
          migration_files=$(find micro-digiservices/database-migrations/src/main/resources/db/migration -name "*.sql" | wc -l 2>/dev/null || echo "0")
          echo "‚úÖ Found $migration_files migration files for deployment"
          
          if [ "$migration_files" -eq 0 ]; then
            echo "‚ùå No migration files found! Check if files are committed to repository."
            exit 1
          fi
          
          # Load production environment with proper export
          if [ -f .env.prod ]; then
            echo "üîß Loading production environment..."
          
            # Export environment variables for Docker Compose
            set -a  # Automatically export all variables
            source .env.prod
            set +a  # Turn off automatic export
          
            # Explicitly export critical variables
            export SPRING_PROFILES_ACTIVE POSTGRES_USER POSTGRES_DATABASE POSTGRES_PASSWORD
            export DB_USERNAME DB_PASSWORD UI_APP_URL BACKEND_APP_URL API_BASE_URL AUTH_SERVER_URL
            export MAIL_HOST MAIL_PORT MAIL_USERNAME MAIL_PASSWORD
            export OAUTH2_CLIENT_ID OAUTH2_SCOPE OAUTH2_RESPONSE_TYPE OAUTH2_CODE_CHALLENGE_METHOD
            export SESSION_COOKIE_SECURE PGADMIN_EMAIL PGADMIN_PASSWORD KAFKA_ADVERTISED_LISTENERS
          
            # Verify critical variables are exported
            echo "‚úÖ Environment verification:"
            echo "POSTGRES_USER: ${POSTGRES_USER:-NOT_SET}"
            echo "DB_USERNAME: ${DB_USERNAME:-NOT_SET}"
            echo "POSTGRES_DATABASE: ${POSTGRES_DATABASE:-NOT_SET}"
          
            if [ -z "$POSTGRES_USER" ] || [ -z "$DB_USERNAME" ] || [ -z "$POSTGRES_DATABASE" ]; then
              echo "‚ùå Critical environment variables not set!"
              exit 1
            fi
          
            echo "‚úÖ Production environment loaded and exported"
          else
            echo "‚ùå .env.prod not found!"
            exit 1
          fi
          
          # Stop existing services gracefully
          echo "üõë Stopping existing services..."
          docker compose down --timeout 30
          
          # Start database first
          echo "üóÑÔ∏è Starting database..."
          docker compose --env-file .env.prod up -d postgresdb
          
          # Wait for database to be ready
          echo "‚è≥ Waiting for database to be ready..."
          timeout 120 bash -c "until docker compose exec -T postgresdb pg_isready -U $POSTGRES_USER -d $POSTGRES_DATABASE; do sleep 3; done"
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Database failed to start!"
            exit 1
          fi
          
          echo "‚úÖ Database is ready"
          
          # Check if we should skip migrations
          SKIP_MIGRATIONS="${{ github.event.inputs.skip_migrations }}"
          if [ "$SKIP_MIGRATIONS" = "true" ]; then
            echo "‚è≠Ô∏è Skipping migrations (manual override)"
          else
            # Run database migrations using the fresh code
            echo "üóÉÔ∏è Running database migrations..."
          
            # Show current migration status
            echo "üìã Current migration status:"
            docker compose exec -T postgresdb psql -U $POSTGRES_USER -d $POSTGRES_DATABASE -c "
              SELECT version, description, installed_on 
              FROM flyway_schema_history 
              ORDER BY installed_rank DESC 
              LIMIT 5;
            " 2>/dev/null || echo "No previous migrations found"
          
            # Run migrations using Docker Flyway
            docker compose --env-file .env.prod --profile migration up flyway-migrations
          
            # Check migration result
            migration_exit_code=$?
            if [ $migration_exit_code -eq 0 ]; then
              echo "‚úÖ Database migrations completed successfully!"
          
              # Show updated migration status
              echo "üìã Updated migration status:"
              docker compose exec -T postgresdb psql -U $POSTGRES_USER -d $POSTGRES_DATABASE -c "
                SELECT version, description, installed_on 
                FROM flyway_schema_history 
                ORDER BY installed_rank DESC 
                LIMIT 5;
              "
            else
              echo "‚ùå Database migrations failed!"
              echo "üìã Migration logs:"
              docker compose logs flyway-migrations
          
              echo "üîÑ Rolling back deployment..."
              docker compose down
          
              # Restore database if backup exists
              if [ -f "$BACKUP_DIR/database_backup.sql" ]; then
                echo "üîÑ Restoring database backup..."
                docker compose --env-file .env.prod up -d postgresdb
                sleep 10
                docker compose exec -T postgresdb psql -U $POSTGRES_USER -d $POSTGRES_DATABASE < "$BACKUP_DIR/database_backup.sql" || echo "Database restore failed"
              fi
          
              exit 1
            fi
          fi
          
          # Start application services
          echo "üöÄ Starting application services..."
          docker compose --env-file .env.prod --profile services up -d
          
          # Clean up source code after deployment (optional)
          echo "üßπ Cleaning up temporary source files..."
          rm -rf micro-digiservices/
          
          # Wait for services to initialize
          echo "‚è≥ Waiting for services to initialize..."
          sleep 45
          
          # Health check services
          echo "ÔøΩ Running health checks..."
          services=("postgresdb:5432" "authorizationserver:8080" "userservice:8085" "gateway:8000" "discoveryserver:5002")
          failed_services=()
          
          for service in "${services[@]}"; do
            IFS=':' read -r name port <<< "$service"
            if timeout 15 bash -c "</dev/tcp/localhost/$port" 2>/dev/null; then
              echo "‚úÖ $name is healthy (port $port)"
            else
              echo "‚ö†Ô∏è $name is not responding (port $port)"
              failed_services+=("$name")
            fi
          done
          
          # Final deployment status
          echo ""
          echo "ÔøΩ Deployment Summary:"
          echo "========================================"
          docker compose ps
          
          if [ ${#failed_services[@]} -eq 0 ]; then
            echo ""
            echo "ÔøΩ DEPLOYMENT SUCCESSFUL!"
            echo "ÔøΩÔ∏è Deployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}"
            echo "ÔøΩ Production URLs:"
            echo "  - Gateway: http://51.91.254.218:8000"
            echo "  - Authorization: http://51.91.254.218:8080"
            echo "  - User Service: http://51.91.254.218:8085"
            echo "  - Discovery: http://51.91.254.218:5002"
            echo ""
            echo "ÔøΩ Backup location: $BACKUP_DIR"
            echo "========================================"
          else
            echo ""
            echo "‚ö†Ô∏è DEPLOYMENT COMPLETED WITH ISSUES"
            echo "Failed services: ${failed_services[*]}"
            echo "ÔøΩ Check logs: docker compose logs [service-name]"
            echo "ÔøΩ Backup available at: $BACKUP_DIR"
            echo "========================================"
          fi

  # Post-deployment verification
  post-deployment:
    needs: [pre-deployment, deploy-production]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: ÔøΩ Verify Deployment
      run: |
        echo "ÔøΩ Post-deployment verification..."
        
        # Test basic connectivity
        services=("8080" "8085" "8000" "5002")
        for port in "${services[@]}"; do
          if curl -f -s --max-time 10 "http://51.91.254.218:$port/actuator/health" >/dev/null; then
            echo "‚úÖ Service on port $port is responding"
          else
            echo "‚ö†Ô∏è Service on port $port is not responding"
          fi
        done
        
    - name: ÔøΩ Deployment Report
      run: |
        echo "ÔøΩ Deployment Report"
        echo "==================="
        echo "ÔøΩÔ∏è Deployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}"
        echo "ÔøΩ Git Commit: ${{ github.sha }}"
        echo "ÔøΩ Triggered by: ${{ github.actor }}"
        echo "ÔøΩ Migration files: ${{ needs.pre-deployment.outputs.migration_count }}"
        echo "ÔøΩ Deployment time: $(date)"
        echo "==================="
