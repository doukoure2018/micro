name: CD - Deploy Microservices to OVH

permissions:
  contents: write

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - micro-digiservices/**
      - docker-compose.yml
      - .env.prod
      - '!micro-digiservices/frontend/**'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:17.2
        env:
          POSTGRES_USER: user2711
          POSTGRES_PASSWORD: admin2711
          POSTGRES_DATABASE: localdb
        ports:
          - 5432:5432
        options:
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Notify deployment start
        run: >
          curl -X POST -H 'Content-type: application/json'
          --data '{"text":":rocket: Microservices deployment to OVH started\nCommit: https://github.com/${{ github.repository }}/commit/${{ github.sha }}\nMessage: ${{ github.event.head_commit.message }}"}'
          ${{ secrets.SLACK_WEBHOOK_URL }}

      - uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Docker Hub login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}
       # ADD THIS NEW STEP HERE
      - name: Configure Maven with Docker credentials
        run: |
          mkdir -p ~/.docker
          echo '{"auths":{"registry-1.docker.io":{"auth":"'$(echo -n "${{ secrets.DOCKERHUB_USERNAME }}:${{ secrets.DOCKERHUB_ACCESS_TOKEN }}" | base64)'"}}}' > ~/.docker/config.json

      - name: Generate build tag
        id: build-number
        run: echo "BUILD_NUMBER=$(date '+%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT

      # Build and push each microservice with Maven/Jib
      - name: Install all modules (including clients)
        working-directory: ./micro-digiservices
        run: mvn -ntp -B install -DskipTests

      - name: Build and push Discovery Server
        working-directory: ./micro-digiservices/discoveryserver
        run: |
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=${{ steps.build-number.outputs.BUILD_NUMBER }} jib:build
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=latest jib:build

      - name: Build and push Gateway
        working-directory: ./micro-digiservices/gateway
        run: |
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=${{ steps.build-number.outputs.BUILD_NUMBER }} jib:build
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=latest jib:build

      - name: Build and push Authorization Server
        working-directory: ./micro-digiservices/authorizationserver
        run: |
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=${{ steps.build-number.outputs.BUILD_NUMBER }} jib:build
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=latest jib:build

      - name: Build and push User Service
        working-directory: ./micro-digiservices/userservice
        run: |
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=${{ steps.build-number.outputs.BUILD_NUMBER }} jib:build
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=latest jib:build

      - name: Build and push E-Credit Service
        working-directory: ./micro-digiservices
        run: |
          mvn -ntp -B install -DskipTests -pl clients
          cd ecreditservice
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=${{ steps.build-number.outputs.BUILD_NUMBER }} jib:build
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=latest jib:build

      - name: Build and push E-Banking Service
        working-directory: ./micro-digiservices/ebanking
        run: |
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=${{ steps.build-number.outputs.BUILD_NUMBER }} jib:build
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=latest jib:build

      - name: Build and push Notification Service
        working-directory: ./micro-digiservices/notificationservice
        run: |
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=${{ steps.build-number.outputs.BUILD_NUMBER }} jib:build
          mvn -ntp -B verify -DskipTests -Ddocker.image.tag=latest jib:build

      - name: Notify images pushed
        run: >
          curl -X POST -H 'Content-type: application/json'
          --data '{"text":":whale: All microservices images pushed to DockerHub!\nTag: ${{ steps.build-number.outputs.BUILD_NUMBER }}"}'
          ${{ secrets.SLACK_WEBHOOK_URL }}

      # Deploy to OVH server - Version optimis√©e
      - name: Deploy to OVH server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.OVH_HOST }}
          username: ${{ secrets.OVH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            set -e  # Arr√™ter en cas d'erreur

            # Se d√©placer dans le r√©pertoire du projet
            cd ~/microservices || { mkdir -p ~/microservices && cd ~/microservices; }

            # G√©rer les changements locaux Git
            if [ -d ".git" ]; then
              echo "üì• Syncing with repository..."
              git stash save "Auto-stash before deployment $(date)" || true
              git fetch origin main
              git reset --hard origin/main
              echo "‚úÖ Repository synchronized"
            else
              echo "üì• Cloning repository..."
              git clone https://github.com/${{ github.repository }} .
              git checkout main
            fi

            # Cr√©er les r√©pertoires n√©cessaires
            echo "üìÅ Creating required directories..."
            mkdir -p logs/{discoveryserver,gateway,authorizationserver,userservice,ecreditservice,ebankingservice,notificationservice,frontend}
            mkdir -p keys

            # V√©rifier que .env.prod existe
            if [ ! -f .env.prod ]; then
              echo "‚ö†Ô∏è .env.prod not found, using .env.docker as template..."
              cp .env.docker .env.prod || { echo "‚ùå No .env.docker found!"; exit 1; }
            fi

            # Charger les variables d'environnement
            export $(cat .env.prod | grep -v '^#' | xargs)

            # Cr√©er le r√©seau Docker si n√©cessaire
            sudo docker network inspect microservices_spring >/dev/null 2>&1 || sudo docker network create microservices_spring

            # Arr√™ter tous les conteneurs existants
            echo "üõë Stopping existing services..."
            sudo docker compose --env-file .env.prod down || true

            # AJOUT IMPORTANT: Forcer le pull de toutes les nouvelles images AVANT de d√©marrer
            echo "üì• Pulling all latest images..."
            sudo docker compose --env-file .env.prod pull

            # Nettoyer les anciennes images
            echo "üßπ Cleaning up old images..."
            sudo docker image prune -f

            # D√©marrer PostgreSQL et Kafka en premier
            echo "üèóÔ∏è Starting infrastructure services..."
            sudo docker compose --env-file .env.prod up -d postgresdb zookeeper kafka

            # Attendre que PostgreSQL soit pr√™t
            echo "‚è≥ Waiting for PostgreSQL..."
            count=0
            until sudo docker exec postgrecontainer pg_isready -U ${POSTGRES_USER:-user2711} || [ $count -eq 30 ]; do
              echo "Waiting for PostgreSQL... ($count/30)"
              sleep 2
              count=$((count + 1))
            done

            if [ $count -eq 30 ]; then
              echo "‚ùå PostgreSQL failed to start!"
              exit 1
            fi

            echo "‚úÖ PostgreSQL is ready"

            # Ex√©cuter les migrations Flyway
            echo "üóÑÔ∏è Running database migrations..."

            MIGRATION_COUNT=$(ls micro-digiservices/database-migrations/src/main/resources/db/migration/*.sql 2>/dev/null | wc -l)
            echo "üìã Found $MIGRATION_COUNT migration files"

            sudo docker run --rm \
              --network microservices_spring \
              -v "$(pwd)/micro-digiservices/database-migrations/src/main/resources/db/migration:/flyway/sql:ro" \
              -e FLYWAY_URL="jdbc:postgresql://postgrecontainer:5432/${POSTGRES_DB:-localdb}" \
              -e FLYWAY_USER="${POSTGRES_USER:-user2711}" \
              -e FLYWAY_PASSWORD="${POSTGRES_PASSWORD:-admin2711}" \
              -e FLYWAY_SCHEMAS="public" \
              -e FLYWAY_TABLE="flyway_schema_history" \
              -e FLYWAY_BASELINE_ON_MIGRATE="true" \
              -e FLYWAY_OUT_OF_ORDER="true" \
              -e FLYWAY_VALIDATE_ON_MIGRATE="false" \
              -e FLYWAY_CLEAN_DISABLED="true" \
              flyway/flyway:11.3.0 \
              migrate || {
                echo "‚ö†Ô∏è Migration encountered issues, attempting repair..."
                sudo docker run --rm \
                  --network microservices_spring \
                  -e FLYWAY_URL="jdbc:postgresql://postgrecontainer:5432/${POSTGRES_DB:-localdb}" \
                  -e FLYWAY_USER="${POSTGRES_USER:-user2711}" \
                  -e FLYWAY_PASSWORD="${POSTGRES_PASSWORD:-admin2711}" \
                  flyway/flyway:11.3.0 \
                  repair

                echo "Retrying migration..."
                sudo docker run --rm \
                  --network microservices_spring \
                  -v "$(pwd)/micro-digiservices/database-migrations/src/main/resources/db/migration:/flyway/sql:ro" \
                  -e FLYWAY_URL="jdbc:postgresql://postgrecontainer:5432/${POSTGRES_DB:-localdb}" \
                  -e FLYWAY_USER="${POSTGRES_USER:-user2711}" \
                  -e FLYWAY_PASSWORD="${POSTGRES_PASSWORD:-admin2711}" \
                  -e FLYWAY_OUT_OF_ORDER="true" \
                  -e FLYWAY_VALIDATE_ON_MIGRATE="false" \
                  flyway/flyway:11.3.0 \
                  migrate || echo "‚ö†Ô∏è Some migrations may need manual intervention"
              }

            # V√©rifier le statut des migrations
            echo "üìä Migration status:"
            APPLIED_MIGRATIONS=$(sudo docker exec postgrecontainer psql -U ${POSTGRES_USER:-user2711} -d ${POSTGRES_DB:-localdb} -t -c \
              "SELECT COUNT(*) FROM flyway_schema_history WHERE success = true;" 2>/dev/null | tr -d ' ')
            echo "‚úÖ $APPLIED_MIGRATIONS migrations successfully applied"

            if [ "$APPLIED_MIGRATIONS" -lt "$MIGRATION_COUNT" ]; then
              echo "‚ö†Ô∏è Warning: Only $APPLIED_MIGRATIONS out of $MIGRATION_COUNT migrations were applied"
            fi

            # D√©marrer Discovery Server en premier
            echo "üîç Starting Discovery Server..."
            sudo docker compose --env-file .env.prod up -d discoveryserver
            sleep 30

            # D√©marrer Gateway et Authorization Server
            echo "üîê Starting Gateway and Authorization Server..."
            sudo docker compose --env-file .env.prod up -d gateway authorizationserver
            sleep 20

            # D√©marrer tous les autres microservices
            echo "üöÄ Starting all microservices..."
            sudo docker compose --env-file .env.prod up -d

            # Attendre le d√©marrage complet
            echo "‚è≥ Waiting for all services to start..."
            sleep 60

            # V√©rifier l'√©tat des services
            echo "üè• Checking services health..."
            services=("postgrecontainer" "kafka" "discoveryserver" "gateway" "authorizationserver" "userservice" "ecreditservice" "ebankingservice" "notificationservice")
            all_healthy=true

            for service in "${services[@]}"; do
              if sudo docker ps | grep -q "$service"; then
                echo "‚úÖ $service is running"
              else
                echo "‚ùå $service is not running"
                all_healthy=false
              fi
            done

            # Afficher les logs en cas de probl√®me
            if [ "$all_healthy" = false ]; then
              echo "‚ö†Ô∏è Some services failed. Recent logs:"
              sudo docker compose --env-file .env.prod logs --tail=50
              exit 1
            fi

            # Afficher les URLs d'acc√®s et le statut
            echo ""
            echo "üåê Deployment successful!"
            echo "================================================"
            echo "Services available at:"
            echo "   ‚Ä¢ Gateway: http://${{ secrets.OVH_HOST }}:8000"
            echo "   ‚Ä¢ Discovery: http://${{ secrets.OVH_HOST }}:5002"
            echo "   ‚Ä¢ Auth Server: http://${{ secrets.OVH_HOST }}:8080"
            echo "   ‚Ä¢ Frontend: http://${{ secrets.OVH_HOST }}:4200"
            echo ""
            echo "Database status:"
            echo "   ‚Ä¢ Migrations: $APPLIED_MIGRATIONS/$MIGRATION_COUNT applied"
            echo "================================================"

      - name: Final success notification
        run: >
          curl -X POST -H 'Content-type: application/json'
          --data '{"text":":white_check_mark: Microservices deployment to OVH complete!\n:globe_with_meridians: Services:\n‚Ä¢ Gateway: http://${{ secrets.OVH_HOST }}:8000\n‚Ä¢ Discovery: http://${{ secrets.OVH_HOST }}:5002\n‚Ä¢ Auth Server: http://${{ secrets.OVH_HOST }}:8080\n‚Ä¢ Frontend: http://${{ secrets.OVH_HOST }}:4200\n:rocket: Build tag: ${{ steps.build-number.outputs.BUILD_NUMBER }}"}'
          ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Error notification
        if: failure()
        run: >
          curl -X POST -H 'Content-type: application/json'
          --data '{"text":":rotating_light: OVH microservices deployment failed!\n:stopwatch: Status: ${{ job.status }}\n:link: Check logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"}'
          ${{ secrets.SLACK_WEBHOOK_URL }}